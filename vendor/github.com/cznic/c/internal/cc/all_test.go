// Copyright 2015 The CC Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cc

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	goscanner "go/scanner"
	"go/token"
	"io"
	"math"
	"os"
	"path"
	"path/filepath"
	"runtime"
	"sort"
	"strings"
	"sync"
	"testing"
	"unicode"

	"github.com/cznic/c/internal/xc"
	"github.com/cznic/golex/lex"
	"github.com/cznic/mathutil"
)

func caller(s string, va ...interface{}) {
	_, fn, fl, _ := runtime.Caller(2)
	fmt.Fprintf(os.Stderr, "caller: %s:%d: ", path.Base(fn), fl)
	fmt.Fprintf(os.Stderr, s, va...)
	fmt.Fprintln(os.Stderr)
	_, fn, fl, _ = runtime.Caller(1)
	fmt.Fprintf(os.Stderr, "\tcallee: %s:%d: ", path.Base(fn), fl)
	fmt.Fprintln(os.Stderr)
}

func dbg(s string, va ...interface{}) {
	if s == "" {
		s = strings.Repeat("%v ", len(va))
	}
	_, fn, fl, _ := runtime.Caller(1)
	fmt.Fprintf(os.Stderr, "dbg %s:%d: ", path.Base(fn), fl)
	fmt.Fprintf(os.Stderr, s, va...)
	fmt.Fprintln(os.Stderr)
}

func TODO(...interface{}) string {
	_, fn, fl, _ := runtime.Caller(1)
	return fmt.Sprintf("TODO: %s:%d:\n", path.Base(fn), fl)
}

func use(...interface{}) {}

// ============================================================================

var (
	oCpp           = flag.String("cpp", "log-cpp", "Send cpp output to fname, if non empty. (\"log.cpp\")")
	oDev           = flag.Bool("dev", false, "Enable dev helpers. (false)")
	oMaxBenchFiles = flag.Int("maxbenchfiles", 1000, "Limit BenchmarkPPParseCorpus to maxfiles files. Unlimited if < 1. (100)")
	oMaxFiles      = flag.Int("maxfiles", 100, "Limit TestPPParseCorpus to maxfiles files. Unlimited if < 1. (100)")
	oMaxToks       = flag.Int("maxtoks", -1, "Limit DevMakeCorpus result to maxtoks tokens. Unlimited if < 1. (-1)")
	oRe            = flag.String("re", "", "File filter regexp. (\"\")")

	//blacklist = []string{
	//	"testdata/gcc-4.9.1/fixincludes",
	//	"testdata/gcc-4.9.1/gcc/",
	//	"testdata/gcc-4.9.1/gcc/ada/tb-gcc.c",
	//	"testdata/gcc-4.9.1/gcc/testsuite/",
	//	"testdata/gcc-4.9.1/libffi/src/",
	//	"testdata/gcc-4.9.1/libgcc/config/",
	//	"testdata/gcc-4.9.1/libgfortran/",
	//	"testdata/gcc-4.9.1/zlib/contrib/minizip/",
	//	"testdata/gcc-4.9.1/zlib/contrib/untgz/",
	//	"testdata/linux-source-3.16.0/arch/powerpc/math-emu/",
	//	"testdata/linux-source-3.16.0/drivers/scsi/aic7xxx/aicasm/",
	//	"testdata/linux-source-3.16.0/drivers/staging/rtl8821ae/btcoexist/",
	//	"testdata/linux-source-3.16.0/sound/pci/pcxhr/",
	//}

	blacklist = []string{ // fe3a84
		"testdata/gcc-4.9.1/fixincludes/tests/",
		"testdata/gcc-4.9.1/gcc/limitx.h",
		"testdata/gcc-4.9.1/gcc/limity.h",
		"testdata/gcc-4.9.1/gcc/testsuite/gcc.dg/cpp/",
		"testdata/gcc-4.9.1/zlib/contrib/minizip/miniunz.c",
		"testdata/gcc-4.9.1/zlib/contrib/minizip/minizip.c",
		"testdata/linux-source-3.16.0/arch/powerpc/math-emu/math.c",
		"testdata/linux-source-3.16.0/drivers/staging/rtl8821ae/btcoexist/HalBtc8812a1Ant.h",
		"testdata/linux-source-3.16.0/sound/pci/pcxhr/pcxhr_core.c",

		"testdata/gcc-4.9.1/boehm-gc/MacOS.c", // uses __option(foo)
	}

	// Only for [dev]tests.
	predefinedMacros = `
#define __STDC_HOSTED__ 1
#define __STDC_VERSION__ 199901L
#define __STDC__ 1
#define __builtin_offsetof(typ, field) __TODO_BUILTIN_OFFSETOF(42)
`
)

func init() {
	flag.IntVar(&yyDebug, "yydebug", 0, "")
	flag.IntVar(&xc.ErrLimit, "maxerrors", 10, "Limit for errors. Unlimited if <= 0. (10)")
	for i, v := range blacklist {
		blacklist[i] = filepath.FromSlash(v)
	}

	sysIncludePaths = []string{
		"/usr/include",
		"/usr/lib/gcc/x86_64-linux-gnu/4.9/include/",
		"/usr/lib/gcc/x86_64-linux-gnu/4.7/include/",
		"/usr/include/x86_64-linux-gnu/",
	}
	for i, v := range sysIncludePaths {
		sysIncludePaths[i] = filepath.FromSlash(v)
	}

	includePaths = []string{
		"",
	}
	for i, v := range includePaths {
		includePaths[i] = filepath.FromSlash(v)
	}

	model = Model{
		Ptr:       {8, 8, nil},
		Void:      {0, 1, nil},
		Char:      {1, 1, nil},
		UChar:     {1, 1, nil},
		Short:     {2, 2, nil},
		UShort:    {2, 2, nil},
		Int:       {4, 4, nil},
		UInt:      {4, 4, nil},
		Long:      {8, 8, nil},
		ULong:     {8, 8, nil},
		LongLong:  {8, 8, nil},
		ULongLong: {8, 8, nil},
		Float:     {4, 4, nil},
		Double:    {8, 8, nil},
		Bool:      {1, 1, nil},
		Complex:   {8, 8, nil},
	}
}

func printError(w io.Writer, pref string, err error) {
	switch x := err.(type) {
	case goscanner.ErrorList:
		for _, v := range x {
			fmt.Fprintf(w, "%s%v\n", pref, v)
		}
	default:
		fmt.Fprintf(w, "%s%v\n", pref, err)
	}
}

func errString(err error) string {
	var b bytes.Buffer
	printError(&b, "", err)
	return b.String()
}

func newRng() *mathutil.FC32 {
	r, _ := mathutil.NewFC32(0, math.MaxInt32, true)
	r.Seed(42)
	return r
}

func testUCNTable(t *testing.T, tab []rune, fok, fother func(rune) bool, fcategory func(rune) bool, tag string) {
	m := map[rune]struct{}{}
	for i := 0; i < len(tab); i += 2 {
		l, h := tab[i], tab[i+1]
		if h == 0 {
			h = l
		}
		for r := rune(l); r <= rune(h); r++ {
			m[r] = struct{}{}
			if !fcategory(r) {
				t.Logf("%s(\\u%04x) == false", tag, r)
			}
		}
	}
	for r := rune(0); r < 0xffff; r++ {
		_, ok := m[r]
		if g, e := fok(r), ok; g != e {
			t.Errorf("%#04x %v %v", r, g, e)
		}

		if ok {
			if g, e := fother(r), false; g != e {
				t.Errorf("%#04x %v %v", r, g, e)
			}
		}
	}
}

func TestUCNDigitsTable(t *testing.T) {
	tab := []rune{
		0x0660, 0x0669, 0x06F0, 0x06F9, 0x0966, 0x096F, 0x09E6, 0x09EF, 0x0A66, 0x0A6F,
		0x0AE6, 0x0AEF, 0x0B66, 0x0B6F, 0x0BE7, 0x0BEF, 0x0C66, 0x0C6F, 0x0CE6, 0x0CEF,
		0x0D66, 0x0D6F, 0x0E50, 0x0E59, 0x0ED0, 0x0ED9, 0x0F20, 0x0F33,
	}
	testUCNTable(t, tab, isUCNDigit, isUCNNonDigit, unicode.IsDigit, "unicode.IsDigit")
}

func TestUCNNonDigitsTable(t *testing.T) {
	tab := []rune{
		0x00AA, 0x0000, 0x00B5, 0x0000, 0x00B7, 0x0000, 0x00BA, 0x0000, 0x00C0, 0x00D6,
		0x00D8, 0x00F6, 0x00F8, 0x01F5, 0x01FA, 0x0217, 0x0250, 0x02A8, 0x02B0, 0x02B8,
		0x02BB, 0x0000, 0x02BD, 0x02C1, 0x02D0, 0x02D1, 0x02E0, 0x02E4, 0x037A, 0x0000,
		0x0386, 0x0000, 0x0388, 0x038A, 0x038C, 0x0000, 0x038E, 0x03A1, 0x03A3, 0x03CE,
		0x03D0, 0x03D6, 0x03DA, 0x0000, 0x03DC, 0x0000, 0x03DE, 0x0000, 0x03E0, 0x0000,
		0x03E2, 0x03F3, 0x0401, 0x040C, 0x040E, 0x044F, 0x0451, 0x045C, 0x045E, 0x0481,
		0x0490, 0x04C4, 0x04C7, 0x04C8, 0x04CB, 0x04CC, 0x04D0, 0x04EB, 0x04EE, 0x04F5,
		0x04F8, 0x04F9, 0x0531, 0x0556, 0x0559, 0x0000, 0x0561, 0x0587, 0x05B0, 0x05B9,
		0x05F0, 0x05F2, 0x0621, 0x063A, 0x0640, 0x0652, 0x0670, 0x06B7, 0x06BA, 0x06BE,
		0x06C0, 0x06CE, 0x06D0, 0x06DC, 0x06E5, 0x06E8, 0x06EA, 0x06ED, 0x0901, 0x0903,
		0x0905, 0x0939, 0x093D, 0x0000, 0x093E, 0x094D, 0x0950, 0x0952, 0x0958, 0x0963,
		0x0981, 0x0983, 0x0985, 0x098C, 0x098F, 0x0990, 0x0993, 0x09A8, 0x09AA, 0x09B0,
		0x09B2, 0x0000, 0x09B6, 0x09B9, 0x09BE, 0x09C4, 0x09C7, 0x09C8, 0x09CB, 0x09CD,
		0x09DC, 0x09DD, 0x09DF, 0x09E3, 0x09F0, 0x09F1, 0x0A02, 0x0000, 0x0A05, 0x0A0A,
		0x0A0F, 0x0A10, 0x0A13, 0x0A28, 0x0A2A, 0x0A30, 0x0A32, 0x0A33, 0x0A35, 0x0A36,
		0x0A38, 0x0A39, 0x0A3E, 0x0A42, 0x0A47, 0x0A48, 0x0A4B, 0x0A4D, 0x0A59, 0x0A5C,
		0x0A5E, 0x0000, 0x0A74, 0x0000, 0x0A81, 0x0A83, 0x0A85, 0x0A8B, 0x0A8D, 0x0000,
		0x0A8F, 0x0A91, 0x0A93, 0x0AA8, 0x0AAA, 0x0AB0, 0x0AB2, 0x0AB3, 0x0AB5, 0x0AB9,
		0x0ABD, 0x0AC5, 0x0AC7, 0x0AC9, 0x0ACB, 0x0ACD, 0x0AD0, 0x0000, 0x0AE0, 0x0000,
		0x0B01, 0x0B03, 0x0B05, 0x0B0C, 0x0B0F, 0x0B10, 0x0B13, 0x0B28, 0x0B2A, 0x0B30,
		0x0B32, 0x0B33, 0x0B36, 0x0B39, 0x0B3D, 0x0000, 0x0B3E, 0x0B43, 0x0B47, 0x0B48,
		0x0B4B, 0x0B4D, 0x0B5C, 0x0B5D, 0x0B5F, 0x0B61, 0x0B82, 0x0B83, 0x0B85, 0x0B8A,
		0x0B8E, 0x0B90, 0x0B92, 0x0B95, 0x0B99, 0x0B9A, 0x0B9C, 0x0000, 0x0B9E, 0x0B9F,
		0x0BA3, 0x0BA4, 0x0BA8, 0x0BAA, 0x0BAE, 0x0BB5, 0x0BB7, 0x0BB9, 0x0BBE, 0x0BC2,
		0x0BC6, 0x0BC8, 0x0BCA, 0x0BCD, 0x0C01, 0x0C03, 0x0C05, 0x0C0C, 0x0C0E, 0x0C10,
		0x0C12, 0x0C28, 0x0C2A, 0x0C33, 0x0C35, 0x0C39, 0x0C3E, 0x0C44, 0x0C46, 0x0C48,
		0x0C4A, 0x0C4D, 0x0C60, 0x0C61, 0x0C82, 0x0C83, 0x0C85, 0x0C8C, 0x0C8E, 0x0C90,
		0x0C92, 0x0CA8, 0x0CAA, 0x0CB3, 0x0CB5, 0x0CB9, 0x0CBE, 0x0CC4, 0x0CC6, 0x0CC8,
		0x0CCA, 0x0CCD, 0x0CDE, 0x0000, 0x0CE0, 0x0CE1, 0x0D02, 0x0D03, 0x0D05, 0x0D0C,
		0x0D0E, 0x0D10, 0x0D12, 0x0D28, 0x0D2A, 0x0D39, 0x0D3E, 0x0D43, 0x0D46, 0x0D48,
		0x0D4A, 0x0D4D, 0x0D60, 0x0D61, 0x0E01, 0x0E3A,

		// In [0], Annex D, Thai [0x0E40, 0x0E5B] overlaps with digits
		// [0x0E50, 0x0E59]. Exclude them.
		0x0E40, 0x0E4F,
		0x0E5A, 0x0E5B,

		0x0E81, 0x0E82,
		0x0E84, 0x0000, 0x0E87, 0x0E88, 0x0E8A, 0x0000, 0x0E8D, 0x0000, 0x0E94, 0x0E97,
		0x0E99, 0x0E9F, 0x0EA1, 0x0EA3, 0x0EA5, 0x0000, 0x0EA7, 0x0000, 0x0EAA, 0x0EAB,
		0x0EAD, 0x0EAE, 0x0EB0, 0x0EB9, 0x0EBB, 0x0EBD, 0x0EC0, 0x0EC4, 0x0EC6, 0x0000,
		0x0EC8, 0x0ECD, 0x0EDC, 0x0EDD, 0x0F00, 0x0000, 0x0F18, 0x0F19, 0x0F35, 0x0000,
		0x0F37, 0x0000, 0x0F39, 0x0000, 0x0F3E, 0x0F47, 0x0F49, 0x0F69, 0x0F71, 0x0F84,
		0x0F86, 0x0F8B, 0x0F90, 0x0F95, 0x0F97, 0x0000, 0x0F99, 0x0FAD, 0x0FB1, 0x0FB7,
		0x0FB9, 0x0000, 0x10A0, 0x10C5, 0x10D0, 0x10F6, 0x1E00, 0x1E9B, 0x1EA0, 0x1EF9,
		0x1F00, 0x1F15, 0x1F18, 0x1F1D, 0x1F20, 0x1F45, 0x1F48, 0x1F4D, 0x1F50, 0x1F57,
		0x1F59, 0x0000, 0x1F5B, 0x0000, 0x1F5D, 0x0000, 0x1F5F, 0x1F7D, 0x1F80, 0x1FB4,
		0x1FB6, 0x1FBC, 0x1FBE, 0x0000, 0x1FC2, 0x1FC4, 0x1FC6, 0x1FCC, 0x1FD0, 0x1FD3,
		0x1FD6, 0x1FDB, 0x1FE0, 0x1FEC, 0x1FF2, 0x1FF4, 0x1FF6, 0x1FFC, 0x203F, 0x2040,
		0x207F, 0x0000, 0x2102, 0x0000, 0x2107, 0x0000, 0x210A, 0x2113, 0x2115, 0x0000,
		0x2118, 0x211D, 0x2124, 0x0000, 0x2126, 0x0000, 0x2128, 0x0000, 0x212A, 0x2131,
		0x2133, 0x2138, 0x2160, 0x2182, 0x3005, 0x3007, 0x3021, 0x3029, 0x3041, 0x3093,
		0x309B, 0x309C, 0x30A1, 0x30F6, 0x30FB, 0x30FC, 0x3105, 0x312C, 0x4E00, 0x9FA5,
		0xAC00, 0xD7A3,
	}
	testUCNTable(t, tab, isUCNNonDigit, isUCNDigit, unicode.IsLetter, "unicode.IsLetter")
}

type x []struct {
	c   rune
	pos token.Pos
}

type scannerTestTab []struct {
	src   string
	chars x
}

func charStr(c rune) string { //TODO later: must be able to use also yySymName
	return yySymName(int(c))
}

func charsStr(chars []lex.Char) (a []string) {
	for _, v := range chars {
		a = append(a, fmt.Sprintf("{%s %d}", charStr(v.Rune), v.Pos()))
	}
	return a
}

func testScan(t *testing.T, newScanner func(src string) scanner, tab scannerTestTab) {
nextTest:
	for ti, test := range tab {
		sc := newScanner(test.src)
		var chars []lex.Char
		var c lex.Char
		for i := 0; rune2class(c.Rune) != ccEOF && i < len(test.src)+2; i++ {
			c = sc.scan()
			chars = append(chars, c)
		}
		if rune2class(c.Rune) != ccEOF {
			t.Errorf("%d: scanner stall %v", ti, charsStr(chars))
			continue
		}

		if g, e := sc.error(), error(nil); g != e {
			t.Errorf("%d: sc.error() %v %v %v", ti, g, e, charsStr(chars))
			continue
		}

		if g, e := len(chars), len(test.chars); g != e {
			t.Errorf("%d: len(chars) %v %v %v", ti, g, e, charsStr(chars))
			continue
		}

		for i, c := range chars {
			c = chars[i]
			e := test.chars[i]
			g := c.Rune
			if rune2class(c.Rune) == ccEOF {
				g = -1
			}
			if e := e.c; g != e {
				t.Errorf("%d: c[%d] %v %v %v", ti, i, charStr(g), charStr(e), charsStr(chars))
				continue nextTest
			}

			if g, e := c.Pos(), e.pos; g != e {
				t.Errorf("%d: pos[%d] %v %v %v", ti, i, g, e, charsStr(chars))
				continue nextTest
			}
		}
	}
}

func TestPPLexer0(t *testing.T) {
	testScan(
		t,
		func(src string) scanner {
			fset := token.NewFileSet()
			file := fset.AddFile("test", -1, len(src))
			r := newUtf8src(strings.NewReader(src), file)
			return newPPLexer(r, false)
		},
		scannerTestTab{
			{"", x{{-1, 1}}},
			{"%0", x{{'%', 1}, {'0', 2}, {-1, 3}}},
			{"%:%:", x{{'%', 1}, {':', 2}, {'%', 3}, {':', 4}, {-1, 5}}},
			{"%>", x{{'%', 1}, {'>', 2}, {-1, 3}}},
			{"0", x{{'0', 1}, {-1, 2}}},
			{"01", x{{'0', 1}, {'1', 2}, {-1, 3}}},
			{"0??/1\n", x{{'0', 1}, {'?', 2}, {'?', 3}, {'/', 4}, {'1', 5}, {'\n', 6}, {-1, 7}}},
			{"0??/1\n2", x{{'0', 1}, {'?', 2}, {'?', 3}, {'/', 4}, {'1', 5}, {'\n', 6}, {'2', 7}, {-1, 8}}},
			{"0??/\n", x{{'0', 1}, {'?', 2}, {'?', 3}, {'/', 4}, {'\n', 5}, {-1, 6}}},
			{"0??/\n2", x{{'0', 1}, {'?', 2}, {'?', 3}, {'/', 4}, {'\n', 5}, {'2', 6}, {-1, 7}}},
			{"0\\1\n", x{{'0', 1}, {'\\', 2}, {'1', 3}, {'\n', 4}, {-1, 5}}},
			{"0\\1\n2", x{{'0', 1}, {'\\', 2}, {'1', 3}, {'\n', 4}, {'2', 5}, {-1, 6}}},
			{"0\\\n", x{{'0', 1}, {-1, 4}}},
			{"0\\\n2", x{{'0', 1}, {'2', 4}, {-1, 5}}},
			{"0\x00", x{{'0', 1}, {0, 2}, {-1, 3}}},
			{"0\x001", x{{'0', 1}, {0, 2}, {'1', 3}, {-1, 4}}},
			{":>", x{{':', 1}, {'>', 2}, {-1, 3}}},
			{"<%", x{{'<', 1}, {'%', 2}, {-1, 3}}},
			{"<:", x{{'<', 1}, {':', 2}, {-1, 3}}},
			{"??!", x{{'?', 1}, {'?', 2}, {'!', 3}, {-1, 4}}},
			{"??!0", x{{'?', 1}, {'?', 2}, {'!', 3}, {'0', 4}, {-1, 5}}},
			{"??!01", x{{'?', 1}, {'?', 2}, {'!', 3}, {'0', 4}, {'1', 5}, {-1, 6}}},
			{"??!=", x{{'?', 1}, {'?', 2}, {'!', 3}, {'=', 4}, {-1, 5}}},
			{"??'", x{{'?', 1}, {'?', 2}, {'\'', 3}, {-1, 4}}},
			{"??(", x{{'?', 1}, {'?', 2}, {'(', 3}, {-1, 4}}},
			{"??)", x{{'?', 1}, {'?', 2}, {')', 3}, {-1, 4}}},
			{"??-", x{{'?', 1}, {'?', 2}, {'-', 3}, {-1, 4}}},
			{"??/", x{{'?', 1}, {'?', 2}, {'/', 3}, {-1, 4}}},
			{"??/1\n", x{{'?', 1}, {'?', 2}, {'/', 3}, {'1', 4}, {'\n', 5}, {-1, 6}}},
			{"??/1\n2", x{{'?', 1}, {'?', 2}, {'/', 3}, {'1', 4}, {'\n', 5}, {'2', 6}, {-1, 7}}},
			{"??/\n", x{{'?', 1}, {'?', 2}, {'/', 3}, {'\n', 4}, {-1, 5}}},
			{"??/\n2", x{{'?', 1}, {'?', 2}, {'/', 3}, {'\n', 4}, {'2', 5}, {-1, 6}}},
			{"??<", x{{'?', 1}, {'?', 2}, {'<', 3}, {-1, 4}}},
			{"??=??=", x{{'?', 1}, {'?', 2}, {'=', 3}, {'?', 4}, {'?', 5}, {'=', 6}, {-1, 7}}},
			{"??>", x{{'?', 1}, {'?', 2}, {'>', 3}, {-1, 4}}},
			{"???!", x{{'?', 1}, {'?', 2}, {'?', 3}, {'!', 4}, {-1, 5}}},
			{"???!0", x{{'?', 1}, {'?', 2}, {'?', 3}, {'!', 4}, {'0', 5}, {-1, 6}}},
			{"???/\n2", x{{'?', 1}, {'?', 2}, {'?', 3}, {'/', 4}, {'\n', 5}, {'2', 6}, {-1, 7}}},
			{"????!0", x{{'?', 1}, {'?', 2}, {'?', 3}, {'?', 4}, {'!', 5}, {'0', 6}, {-1, 7}}},
			{"???x0", x{{'?', 1}, {'?', 2}, {'?', 3}, {'x', 4}, {'0', 5}, {-1, 6}}},
			{"???x??!0", x{{'?', 1}, {'?', 2}, {'?', 3}, {'x', 4}, {'?', 5}, {'?', 6}, {'!', 7}, {'0', 8}, {-1, 9}}},
			{"??x0", x{{'?', 1}, {'?', 2}, {'x', 3}, {'0', 4}, {-1, 5}}},
			{"??x??!0", x{{'?', 1}, {'?', 2}, {'x', 3}, {'?', 4}, {'?', 5}, {'!', 6}, {'0', 7}, {-1, 8}}},
			{"?x0", x{{'?', 1}, {'x', 2}, {'0', 3}, {-1, 4}}},
			{"?x??!0", x{{'?', 1}, {'x', 2}, {'?', 3}, {'?', 4}, {'!', 5}, {'0', 6}, {-1, 7}}},
			{"@", x{{'@', 1}, {-1, 2}}},
			{"@%", x{{'@', 1}, {'%', 2}, {-1, 3}}},
			{"@%0", x{{'@', 1}, {'%', 2}, {'0', 3}, {-1, 4}}},
			{"@%:", x{{'@', 1}, {'%', 2}, {':', 3}, {-1, 4}}},
			{"@%:0", x{{'@', 1}, {'%', 2}, {':', 3}, {'0', 4}, {-1, 5}}},
			{"@%:01", x{{'@', 1}, {'%', 2}, {':', 3}, {'0', 4}, {'1', 5}, {-1, 6}}},
			{"@??=", x{{'@', 1}, {'?', 2}, {'?', 3}, {'=', 4}, {-1, 5}}},
			{"\"(a\\\nz", x{{'"', 1}, {'(', 2}, {'a', 3}, {'z', 6}, {-1, 7}}},
			{"\\1\n", x{{'\\', 1}, {'1', 2}, {'\n', 3}, {-1, 4}}},
			{"\\1\n2", x{{'\\', 1}, {'1', 2}, {'\n', 3}, {'2', 4}, {-1, 5}}},
			{"\\\n", x{{-1, 3}}},
			{"\\\n2", x{{'2', 3}, {-1, 4}}},
			{"\r", x{{-1, 2}}},
			{"\r0", x{{'0', 2}, {-1, 3}}},
			{"\r01", x{{'0', 2}, {'1', 3}, {-1, 4}}},
			{"\x00", x{{0, 1}, {-1, 2}}},
			{"\x000", x{{0, 1}, {'0', 2}, {-1, 3}}},
		},
	)
}

func TestPPLexer0Trigraphs(t *testing.T) {
	testScan(
		t,
		func(src string) scanner {
			fset := token.NewFileSet()
			file := fset.AddFile("test", -1, len(src))
			r := newUtf8src(strings.NewReader(src), file)
			return newPPLexer(r, true)
		},
		scannerTestTab{
			{"", x{{-1, 1}}},
			{"%0", x{{'%', 1}, {'0', 2}, {-1, 3}}},
			{"%:%:", x{{'%', 1}, {':', 2}, {'%', 3}, {':', 4}, {-1, 5}}},
			{"%>", x{{'%', 1}, {'>', 2}, {-1, 3}}},
			{"0", x{{'0', 1}, {-1, 2}}},
			{"01", x{{'0', 1}, {'1', 2}, {-1, 3}}},
			{"0??/1\n", x{{'0', 1}, {'\\', 2}, {'1', 5}, {'\n', 6}, {-1, 7}}},
			{"0??/1\n2", x{{'0', 1}, {'\\', 2}, {'1', 5}, {'\n', 6}, {'2', 7}, {-1, 8}}},
			{"0??/\n", x{{'0', 1}, {-1, 6}}},
			{"0??/\n2", x{{'0', 1}, {'2', 6}, {-1, 7}}},
			{"0\\1\n", x{{'0', 1}, {'\\', 2}, {'1', 3}, {'\n', 4}, {-1, 5}}},
			{"0\\1\n2", x{{'0', 1}, {'\\', 2}, {'1', 3}, {'\n', 4}, {'2', 5}, {-1, 6}}},
			{"0\\\n", x{{'0', 1}, {-1, 4}}},
			{"0\\\n2", x{{'0', 1}, {'2', 4}, {-1, 5}}},
			{"0\x00", x{{'0', 1}, {0, 2}, {-1, 3}}},
			{"0\x001", x{{'0', 1}, {0, 2}, {'1', 3}, {-1, 4}}},
			{":>", x{{':', 1}, {'>', 2}, {-1, 3}}},
			{"<%", x{{'<', 1}, {'%', 2}, {-1, 3}}},
			{"<:", x{{'<', 1}, {':', 2}, {-1, 3}}},
			{"??!", x{{'|', 1}, {-1, 4}}},
			{"??!0", x{{'|', 1}, {'0', 4}, {-1, 5}}},
			{"??!01", x{{'|', 1}, {'0', 4}, {'1', 5}, {-1, 6}}},
			{"??!=", x{{'|', 1}, {'=', 4}, {-1, 5}}},
			{"??'", x{{'^', 1}, {-1, 4}}},
			{"??(", x{{'[', 1}, {-1, 4}}},
			{"??)", x{{']', 1}, {-1, 4}}},
			{"??-", x{{'~', 1}, {-1, 4}}},
			{"??/", x{{'\\', 1}, {-1, 4}}},
			{"??/1\n", x{{'\\', 1}, {'1', 4}, {'\n', 5}, {-1, 6}}},
			{"??/1\n2", x{{'\\', 1}, {'1', 4}, {'\n', 5}, {'2', 6}, {-1, 7}}},
			{"??/\n", x{{-1, 5}}},
			{"??/\n2", x{{'2', 5}, {-1, 6}}},
			{"??<", x{{'{', 1}, {-1, 4}}},
			{"??=??=", x{{'#', 1}, {'#', 4}, {-1, 7}}},
			{"??>", x{{'}', 1}, {-1, 4}}},
			{"???!", x{{'?', 1}, {'|', 2}, {-1, 5}}},
			{"???!0", x{{'?', 1}, {'|', 2}, {'0', 5}, {-1, 6}}},
			{"???/\n2", x{{'?', 1}, {'2', 6}, {-1, 7}}},
			{"????!0", x{{'?', 1}, {'?', 2}, {'|', 3}, {'0', 6}, {-1, 7}}},
			{"???x0", x{{'?', 1}, {'?', 2}, {'?', 3}, {'x', 4}, {'0', 5}, {-1, 6}}},
			{"???x??!0", x{{'?', 1}, {'?', 2}, {'?', 3}, {'x', 4}, {'|', 5}, {'0', 8}, {-1, 9}}},
			{"??x0", x{{'?', 1}, {'?', 2}, {'x', 3}, {'0', 4}, {-1, 5}}},
			{"??x??!0", x{{'?', 1}, {'?', 2}, {'x', 3}, {'|', 4}, {'0', 7}, {-1, 8}}},
			{"?x0", x{{'?', 1}, {'x', 2}, {'0', 3}, {-1, 4}}},
			{"?x??!0", x{{'?', 1}, {'x', 2}, {'|', 3}, {'0', 6}, {-1, 7}}},
			{"@", x{{'@', 1}, {-1, 2}}},
			{"@%", x{{'@', 1}, {'%', 2}, {-1, 3}}},
			{"@%0", x{{'@', 1}, {'%', 2}, {'0', 3}, {-1, 4}}},
			{"@%:", x{{'@', 1}, {'%', 2}, {':', 3}, {-1, 4}}},
			{"@%:0", x{{'@', 1}, {'%', 2}, {':', 3}, {'0', 4}, {-1, 5}}},
			{"@%:01", x{{'@', 1}, {'%', 2}, {':', 3}, {'0', 4}, {'1', 5}, {-1, 6}}},
			{"@??=", x{{'@', 1}, {'#', 2}, {-1, 5}}},
			{"\"(a\\\nz", x{{'"', 1}, {'(', 2}, {'a', 3}, {'z', 6}, {-1, 7}}},
			{"\\1\n", x{{'\\', 1}, {'1', 2}, {'\n', 3}, {-1, 4}}},
			{"\\1\n2", x{{'\\', 1}, {'1', 2}, {'\n', 3}, {'2', 4}, {-1, 5}}},
			{"\\\n", x{{-1, 3}}},
			{"\\\n2", x{{'2', 3}, {-1, 4}}},
			{"\r", x{{-1, 2}}},
			{"\r0", x{{'0', 2}, {-1, 3}}},
			{"\r01", x{{'0', 2}, {'1', 3}, {-1, 4}}},
			{"\x00", x{{0, 1}, {-1, 2}}},
			{"\x000", x{{0, 1}, {'0', 2}, {-1, 3}}},
		},
	)
}

func TestPPLexer(t *testing.T) {
	testScan(
		t,
		func(src string) scanner {
			fset := token.NewFileSet()
			file := fset.AddFile("test", -1, len(src))
			r := newUtf8src(strings.NewReader(src), file)
			return newLexer(r, false)
		},
		scannerTestTab{
			{"!=", x{{NEQ, 1}, {'\n', 3}, {-1, 3}}},
			{"", x{{'\n', 1}, {-1, 1}}},
			{"##", x{{PPPASTE, 1}, {'\n', 3}, {-1, 3}}},
			{"#%:", x{{PPPASTE, 1}, {'\n', 4}, {-1, 4}}},
			{"%:#", x{{PPPASTE, 1}, {'\n', 4}, {-1, 4}}},
			{"%:%#", x{{'#', 1}, {'%', 3}, {'#', 4}, {'\n', 5}, {-1, 5}}},
			{"%:%%:", x{{'#', 1}, {'%', 3}, {'#', 4}, {'\n', 6}, {-1, 6}}},
			{"%:%:", x{{PPPASTE, 1}, {'\n', 5}, {-1, 5}}},
			{"%=", x{{MODASSIGN, 1}, {'\n', 3}, {-1, 3}}},
			{"%>", x{{'}', 1}, {'\n', 3}, {-1, 3}}},
			{"%@%", x{{'%', 1}, {'@', 2}, {'%', 3}, {'\n', 4}, {-1, 4}}},
			{"&", x{{'&', 1}, {'\n', 2}, {-1, 2}}},
			{"&&", x{{ANDAND, 1}, {'\n', 3}, {-1, 3}}},
			{"&=", x{{ANDASSIGN, 1}, {'\n', 3}, {-1, 3}}},
			{"&@", x{{'&', 1}, {'@', 2}, {'\n', 3}, {-1, 3}}},
			{"*", x{{'*', 1}, {'\n', 2}, {-1, 2}}},
			{"*=", x{{MULASSIGN, 1}, {'\n', 3}, {-1, 3}}},
			{"*@", x{{'*', 1}, {'@', 2}, {'\n', 3}, {-1, 3}}},
			{"+", x{{'+', 1}, {'\n', 2}, {-1, 2}}},
			{"++", x{{INC, 1}, {'\n', 3}, {-1, 3}}},
			{"+=", x{{ADDASSIGN, 1}, {'\n', 3}, {-1, 3}}},
			{"+@", x{{'+', 1}, {'@', 2}, {'\n', 3}, {-1, 3}}},
			{"--", x{{DEC, 1}, {'\n', 3}, {-1, 3}}},
			{"-=", x{{SUBASSIGN, 1}, {'\n', 3}, {-1, 3}}},
			{"->", x{{ARROW, 1}, {'\n', 3}, {-1, 3}}},
			{".", x{{'.', 1}, {'\n', 2}, {-1, 2}}},
			{"...@", x{{DDD, 1}, {'@', 4}, {'\n', 5}, {-1, 5}}},
			{"..@", x{{'.', 1}, {'.', 2}, {'@', 3}, {'\n', 4}, {-1, 4}}},
			{".1", x{{FLOATCONST, 1}, {'\n', 3}, {-1, 3}}},
			{".@", x{{'.', 1}, {'@', 2}, {'\n', 3}, {-1, 3}}},
			{"/=", x{{DIVASSIGN, 1}, {'\n', 3}, {-1, 3}}},
			{"0", x{{INTCONST, 1}, {'\n', 2}, {-1, 2}}},
			{":>", x{{']', 1}, {'\n', 3}, {-1, 3}}},
			{"<%", x{{'{', 1}, {'\n', 3}, {-1, 3}}},
			{"<:", x{{'[', 1}, {'\n', 3}, {-1, 3}}},
			{"<<", x{{LSH, 1}, {'\n', 3}, {-1, 3}}},
			{"<<=", x{{LSHASSIGN, 1}, {'\n', 4}, {-1, 4}}},
			{"<=", x{{LEQ, 1}, {'\n', 3}, {-1, 3}}},
			{"==", x{{EQ, 1}, {'\n', 3}, {-1, 3}}},
			{">=", x{{GEQ, 1}, {'\n', 3}, {-1, 3}}},
			{">>", x{{RSH, 1}, {'\n', 3}, {-1, 3}}},
			{">>=", x{{RSHASSIGN, 1}, {'\n', 4}, {-1, 4}}},
			{"?#??!@", x{{'?', 1}, {'#', 2}, {'?', 3}, {'?', 4}, {'!', 5}, {'@', 6}, {'\n', 7}, {-1, 7}}},
			{"?#@", x{{'?', 1}, {'#', 2}, {'@', 3}, {'\n', 4}, {-1, 4}}},
			{"??!", x{{'?', 1}, {'?', 2}, {'!', 3}, {'\n', 4}, {-1, 4}}},
			{"??!#", x{{'?', 1}, {'?', 2}, {'!', 3}, {'#', 4}, {'\n', 5}, {-1, 5}}},
			{"??!=", x{{'?', 1}, {'?', 2}, {NEQ, 3}, {'\n', 5}, {-1, 5}}},
			{"??!@", x{{'?', 1}, {'?', 2}, {'!', 3}, {'@', 4}, {'\n', 5}, {-1, 5}}},
			{"??!@#", x{{'?', 1}, {'?', 2}, {'!', 3}, {'@', 4}, {'#', 5}, {'\n', 6}, {-1, 6}}},
			{"??#??!@", x{{'?', 1}, {'?', 2}, {'#', 3}, {'?', 4}, {'?', 5}, {'!', 6}, {'@', 7}, {'\n', 8}, {-1, 8}}},
			{"??#@", x{{'?', 1}, {'?', 2}, {'#', 3}, {'@', 4}, {'\n', 5}, {-1, 5}}},
			{"??'", x{{'?', 1}, {'?', 2}, {'\'', 3}, {'\n', 4}, {-1, 4}}},
			{"??(", x{{'?', 1}, {'?', 2}, {'(', 3}, {'\n', 4}, {-1, 4}}},
			{"??)", x{{'?', 1}, {'?', 2}, {')', 3}, {'\n', 4}, {-1, 4}}},
			{"??-", x{{'?', 1}, {'?', 2}, {'-', 3}, {'\n', 4}, {-1, 4}}},
			{"??/", x{{'?', 1}, {'?', 2}, {'/', 3}, {'\n', 4}, {-1, 4}}},
			{"??/@\n", x{{'?', 1}, {'?', 2}, {'/', 3}, {'@', 4}, {'\n', 5}, {-1, 6}}},
			{"??/@\n#", x{{'?', 1}, {'?', 2}, {'/', 3}, {'@', 4}, {'\n', 5}, {'#', 6}, {'\n', 7}, {-1, 7}}},
			{"??/\n", x{{'?', 1}, {'?', 2}, {'/', 3}, {'\n', 4}, {-1, 5}}},
			{"??/\n@", x{{'?', 1}, {'?', 2}, {'/', 3}, {'\n', 4}, {'@', 5}, {'\n', 6}, {-1, 6}}},
			{"??<", x{{'?', 1}, {'?', 2}, {'<', 3}, {'\n', 4}, {-1, 4}}},
			{"??=??=", x{{'?', 1}, {'?', 2}, {'=', 3}, {'?', 4}, {'?', 5}, {'=', 6}, {'\n', 7}, {-1, 7}}},
			{"??>", x{{'?', 1}, {'?', 2}, {'>', 3}, {'\n', 4}, {-1, 4}}},
			{"???!", x{{'?', 1}, {'?', 2}, {'?', 3}, {'!', 4}, {'\n', 5}, {-1, 5}}},
			{"???!@", x{{'?', 1}, {'?', 2}, {'?', 3}, {'!', 4}, {'@', 5}, {'\n', 6}, {-1, 6}}},
			{"???#??!@", x{{'?', 1}, {'?', 2}, {'?', 3}, {'#', 4}, {'?', 5}, {'?', 6}, {'!', 7}, {'@', 8}, {'\n', 9}, {-1, 9}}},
			{"???#@", x{{'?', 1}, {'?', 2}, {'?', 3}, {'#', 4}, {'@', 5}, {'\n', 6}, {-1, 6}}},
			{"???/\n@", x{{'?', 1}, {'?', 2}, {'?', 3}, {'/', 4}, {'\n', 5}, {'@', 6}, {'\n', 7}, {-1, 7}}},
			{"????!@", x{{'?', 1}, {'?', 2}, {'?', 3}, {'?', 4}, {'!', 5}, {'@', 6}, {'\n', 7}, {-1, 7}}},
			{"@", x{{'@', 1}, {'\n', 2}, {-1, 2}}},
			{"@#", x{{'@', 1}, {'#', 2}, {'\n', 3}, {-1, 3}}},
			{"@%", x{{'@', 1}, {'%', 2}, {'\n', 3}, {-1, 3}}},
			{"@%#", x{{'@', 1}, {'%', 2}, {'#', 3}, {'\n', 4}, {-1, 4}}},
			{"@%:", x{{'@', 1}, {'#', 2}, {'\n', 4}, {-1, 4}}},
			{"@%:$", x{{'@', 1}, {'#', 2}, {IDENTIFIER, 4}, {'\n', 5}, {-1, 5}}},
			{"@%:$#", x{{'@', 1}, {'#', 2}, {IDENTIFIER, 4}, {'#', 5}, {'\n', 6}, {-1, 6}}},
			{"@%:@", x{{'@', 1}, {'#', 2}, {'@', 4}, {'\n', 5}, {-1, 5}}},
			{"@%:@#", x{{'@', 1}, {'#', 2}, {'@', 4}, {'#', 5}, {'\n', 6}, {-1, 6}}},
			{"@'\\''%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\0'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\01'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 7}, {'\n', 8}, {-1, 8}}},
			{"@'\\012'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 8}, {'\n', 9}, {-1, 9}}},
			{"@'\\?'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\U12345678'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 14}, {'\n', 15}, {-1, 15}}},
			{"@'\\\"'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\\\'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\a'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\b'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\f'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\n'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\r'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\t'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\u1234'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 10}, {'\n', 11}, {-1, 11}}},
			{"@'\\v'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\x12'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 8}, {'\n', 9}, {-1, 9}}},
			{"@??/@\n", x{{'@', 1}, {'?', 2}, {'?', 3}, {'/', 4}, {'@', 5}, {'\n', 6}, {-1, 7}}},
			{"@??/@\n@", x{{'@', 1}, {'?', 2}, {'?', 3}, {'/', 4}, {'@', 5}, {'\n', 6}, {'@', 7}, {'\n', 8}, {-1, 8}}},
			{"@??/\n", x{{'@', 1}, {'?', 2}, {'?', 3}, {'/', 4}, {'\n', 5}, {-1, 6}}},
			{"@??/\n@", x{{'@', 1}, {'?', 2}, {'?', 3}, {'/', 4}, {'\n', 5}, {'@', 6}, {'\n', 7}, {-1, 7}}},
			{"@??=", x{{'@', 1}, {'?', 2}, {'?', 3}, {'=', 4}, {'\n', 5}, {-1, 5}}},
			{"@\\#\n", x{{'@', 1}, {'\\', 2}, {'#', 3}, {'\n', 4}, {-1, 5}}},
			{"@\\#\n@", x{{'@', 1}, {'\\', 2}, {'#', 3}, {'\n', 4}, {'@', 5}, {'\n', 6}, {-1, 6}}},
			{"@\\\n", x{{'@', 1}, {'\n', 4}, {-1, 4}}},
			{"@\\\n#", x{{'@', 1}, {'#', 4}, {'\n', 5}, {-1, 5}}},
			{"@\x00", x{{'@', 1}, {0, 2}, {'\n', 3}, {-1, 3}}},
			{"@\x00#", x{{'@', 1}, {0, 2}, {'#', 3}, {'\n', 4}, {-1, 4}}},
			{"L", x{{IDENTIFIER, 1}, {'\n', 2}, {-1, 2}}},
			{"L'x'", x{{LONGCHARCONST, 1}, {'\n', 5}, {-1, 5}}},
			{"L\"\"", x{{LONGSTRINGLITERAL, 1}, {'\n', 4}, {-1, 4}}},
			{"L\"\"@", x{{LONGSTRINGLITERAL, 1}, {'@', 4}, {'\n', 5}, {-1, 5}}},
			{"L\n", x{{IDENTIFIER, 1}, {'\n', 2}, {-1, 3}}},
			{"\"(a\\\n\\u010d\\U0000010D\\\\\\'\\\"\"", x{{STRINGLITERAL, 1}, {'\n', 29}, {-1, 29}}},
			{"\"\"", x{{STRINGLITERAL, 1}, {'\n', 3}, {-1, 3}}},
			{"\"\"@", x{{STRINGLITERAL, 1}, {'@', 3}, {'\n', 4}, {-1, 4}}},
			{"\\@\n", x{{'\\', 1}, {'@', 2}, {'\n', 3}, {-1, 4}}},
			{"\\@\n#", x{{'\\', 1}, {'@', 2}, {'\n', 3}, {'#', 4}, {'\n', 5}, {-1, 5}}},
			{"\\\n", x{{'\n', 3}, {-1, 3}}},
			{"\\\n@", x{{'@', 3}, {'\n', 4}, {-1, 4}}},
			{"\n", x{{'\n', 1}, {-1, 2}}},
			{"\r", x{{'\n', 2}, {-1, 2}}},
			{"\r@", x{{'@', 2}, {'\n', 3}, {-1, 3}}},
			{"\r@#", x{{'@', 2}, {'#', 3}, {'\n', 4}, {-1, 4}}},
			{"\x00", x{{0, 1}, {'\n', 2}, {-1, 2}}},
			{"\x00@", x{{0, 1}, {'@', 2}, {'\n', 3}, {-1, 3}}},
			{"^=", x{{XORASSIGN, 1}, {'\n', 3}, {-1, 3}}},
			{"_", x{{IDENTIFIER, 1}, {'\n', 2}, {-1, 2}}},
			{"_@", x{{IDENTIFIER, 1}, {'@', 2}, {'\n', 3}, {-1, 3}}},
			{"_Bool", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"_Complex", x{{IDENTIFIER, 1}, {'\n', 9}, {-1, 9}}},
			{"_Imaginary", x{{IDENTIFIER, 1}, {'\n', 11}, {-1, 11}}},
			{"_a", x{{IDENTIFIER, 1}, {'\n', 3}, {-1, 3}}},
			{"auto", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"a·", x{{IDENTIFIER, 1}, {'\n', 4}, {-1, 4}}},
			{"a·z", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"brea", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"breaj", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"break", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"breaks", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"case", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"char", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"const", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"continue", x{{IDENTIFIER, 1}, {'\n', 9}, {-1, 9}}},
			{"default", x{{IDENTIFIER, 1}, {'\n', 8}, {-1, 8}}},
			{"define", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"do", x{{IDENTIFIER, 1}, {'\n', 3}, {-1, 3}}},
			{"double", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"elif", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"else", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"endif", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"enum", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"error", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"extern", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"float", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"for", x{{IDENTIFIER, 1}, {'\n', 4}, {-1, 4}}},
			{"goto", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"if", x{{IDENTIFIER, 1}, {'\n', 3}, {-1, 3}}},
			{"ifdef", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"ifndef", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"include", x{{IDENTIFIER, 1}, {'\n', 8}, {-1, 8}}},
			{"inline", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"int", x{{IDENTIFIER, 1}, {'\n', 4}, {-1, 4}}},
			{"line", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"long", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"pragma", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"register", x{{IDENTIFIER, 1}, {'\n', 9}, {-1, 9}}},
			{"restrict", x{{IDENTIFIER, 1}, {'\n', 9}, {-1, 9}}},
			{"return", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"short", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"signed", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"sizeof", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"static", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"struct", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"switch", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"typedef", x{{IDENTIFIER, 1}, {'\n', 8}, {-1, 8}}},
			{"undef", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"union", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"unsigned", x{{IDENTIFIER, 1}, {'\n', 9}, {-1, 9}}},
			{"void", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"volatile", x{{IDENTIFIER, 1}, {'\n', 9}, {-1, 9}}},
			{"while", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"|=", x{{ORASSIGN, 1}, {'\n', 3}, {-1, 3}}},
			{"||", x{{OROR, 1}, {'\n', 3}, {-1, 3}}},
			{"·", x{{IDENTIFIER, 1}, {'\n', 3}, {-1, 3}}},
			{"·z", x{{IDENTIFIER, 1}, {'\n', 4}, {-1, 4}}},
			{`""`, x{{STRINGLITERAL, 1}, {'\n', 3}, {-1, 3}}},
		},
	)
}

func TestPPLexerTrigraph(t *testing.T) {
	testScan(
		t,
		func(src string) scanner {
			fset := token.NewFileSet()
			file := fset.AddFile("test", -1, len(src))
			r := newUtf8src(strings.NewReader(src), file)
			return newLexer(r, true)
		},
		scannerTestTab{
			{"!=", x{{NEQ, 1}, {'\n', 3}, {-1, 3}}},
			{"", x{{'\n', 1}, {-1, 1}}},
			{"##", x{{PPPASTE, 1}, {'\n', 3}, {-1, 3}}},
			{"#%:", x{{PPPASTE, 1}, {'\n', 4}, {-1, 4}}},
			{"%:#", x{{PPPASTE, 1}, {'\n', 4}, {-1, 4}}},
			{"%:%:", x{{PPPASTE, 1}, {'\n', 5}, {-1, 5}}},
			{"%=", x{{MODASSIGN, 1}, {'\n', 3}, {-1, 3}}},
			{"%>", x{{'}', 1}, {'\n', 3}, {-1, 3}}},
			{"%@", x{{'%', 1}, {'@', 2}, {'\n', 3}, {-1, 3}}},
			{"&", x{{'&', 1}, {'\n', 2}, {-1, 2}}},
			{"&&", x{{ANDAND, 1}, {'\n', 3}, {-1, 3}}},
			{"&=", x{{ANDASSIGN, 1}, {'\n', 3}, {-1, 3}}},
			{"&@", x{{'&', 1}, {'@', 2}, {'\n', 3}, {-1, 3}}},
			{"*", x{{'*', 1}, {'\n', 2}, {-1, 2}}},
			{"*=", x{{MULASSIGN, 1}, {'\n', 3}, {-1, 3}}},
			{"*@", x{{'*', 1}, {'@', 2}, {'\n', 3}, {-1, 3}}},
			{"+", x{{'+', 1}, {'\n', 2}, {-1, 2}}},
			{"++", x{{INC, 1}, {'\n', 3}, {-1, 3}}},
			{"+=", x{{ADDASSIGN, 1}, {'\n', 3}, {-1, 3}}},
			{"+@", x{{'+', 1}, {'@', 2}, {'\n', 3}, {-1, 3}}},
			{"--", x{{DEC, 1}, {'\n', 3}, {-1, 3}}},
			{"-=", x{{SUBASSIGN, 1}, {'\n', 3}, {-1, 3}}},
			{"->", x{{ARROW, 1}, {'\n', 3}, {-1, 3}}},
			{".", x{{'.', 1}, {'\n', 2}, {-1, 2}}},
			{"...@", x{{DDD, 1}, {'@', 4}, {'\n', 5}, {-1, 5}}},
			{"..@", x{{'.', 1}, {'.', 2}, {'@', 3}, {'\n', 4}, {-1, 4}}},
			{".1", x{{FLOATCONST, 1}, {'\n', 3}, {-1, 3}}},
			{".@", x{{'.', 1}, {'@', 2}, {'\n', 3}, {-1, 3}}},
			{"/=", x{{DIVASSIGN, 1}, {'\n', 3}, {-1, 3}}},
			{"0", x{{INTCONST, 1}, {'\n', 2}, {-1, 2}}},
			{":>", x{{']', 1}, {'\n', 3}, {-1, 3}}},
			{"<%", x{{'{', 1}, {'\n', 3}, {-1, 3}}},
			{"<:", x{{'[', 1}, {'\n', 3}, {-1, 3}}},
			{"<<", x{{LSH, 1}, {'\n', 3}, {-1, 3}}},
			{"<<=", x{{LSHASSIGN, 1}, {'\n', 4}, {-1, 4}}},
			{"<=", x{{LEQ, 1}, {'\n', 3}, {-1, 3}}},
			{"==", x{{EQ, 1}, {'\n', 3}, {-1, 3}}},
			{">=", x{{GEQ, 1}, {'\n', 3}, {-1, 3}}},
			{">>", x{{RSH, 1}, {'\n', 3}, {-1, 3}}},
			{">>=", x{{RSHASSIGN, 1}, {'\n', 4}, {-1, 4}}},
			{"?#??!@", x{{'?', 1}, {'#', 2}, {'|', 3}, {'@', 6}, {'\n', 7}, {-1, 7}}},
			{"?#@", x{{'?', 1}, {'#', 2}, {'@', 3}, {'\n', 4}, {-1, 4}}},
			{"??!", x{{'|', 1}, {'\n', 4}, {-1, 4}}},
			{"??!=", x{{ORASSIGN, 1}, {'\n', 5}, {-1, 5}}},
			{"??!@", x{{'|', 1}, {'@', 4}, {'\n', 5}, {-1, 5}}},
			{"??!@#", x{{'|', 1}, {'@', 4}, {'#', 5}, {'\n', 6}, {-1, 6}}},
			{"??#??!@", x{{'?', 1}, {'?', 2}, {'#', 3}, {'|', 4}, {'@', 7}, {'\n', 8}, {-1, 8}}},
			{"??#@", x{{'?', 1}, {'?', 2}, {'#', 3}, {'@', 4}, {'\n', 5}, {-1, 5}}},
			{"??'", x{{'^', 1}, {'\n', 4}, {-1, 4}}},
			{"??(", x{{'[', 1}, {'\n', 4}, {-1, 4}}},
			{"??)", x{{']', 1}, {'\n', 4}, {-1, 4}}},
			{"??-", x{{'~', 1}, {'\n', 4}, {-1, 4}}},
			{"??/", x{{'\\', 1}, {'\n', 4}, {-1, 4}}},
			{"??/@\n", x{{'\\', 1}, {'@', 4}, {'\n', 5}, {-1, 6}}},
			{"??/@\n#", x{{'\\', 1}, {'@', 4}, {'\n', 5}, {'#', 6}, {'\n', 7}, {-1, 7}}},
			{"??/\n", x{{'\n', 5}, {-1, 5}}},
			{"??/\n@", x{{'@', 5}, {'\n', 6}, {-1, 6}}},
			{"??<", x{{'{', 1}, {'\n', 4}, {-1, 4}}},
			{"??=??=", x{{PPPASTE, 1}, {'\n', 7}, {-1, 7}}},
			{"??>", x{{'}', 1}, {'\n', 4}, {-1, 4}}},
			{"???!", x{{'?', 1}, {'|', 2}, {'\n', 5}, {-1, 5}}},
			{"???!@", x{{'?', 1}, {'|', 2}, {'@', 5}, {'\n', 6}, {-1, 6}}},
			{"???#??!@", x{{'?', 1}, {'?', 2}, {'?', 3}, {'#', 4}, {'|', 5}, {'@', 8}, {'\n', 9}, {-1, 9}}},
			{"???#@", x{{'?', 1}, {'?', 2}, {'?', 3}, {'#', 4}, {'@', 5}, {'\n', 6}, {-1, 6}}},
			{"???/\n@", x{{'?', 1}, {'@', 6}, {'\n', 7}, {-1, 7}}},
			{"????!@", x{{'?', 1}, {'?', 2}, {'|', 3}, {'@', 6}, {'\n', 7}, {-1, 7}}},
			{"@", x{{'@', 1}, {'\n', 2}, {-1, 2}}},
			{"@#", x{{'@', 1}, {'#', 2}, {'\n', 3}, {-1, 3}}},
			{"@%", x{{'@', 1}, {'%', 2}, {'\n', 3}, {-1, 3}}},
			{"@%:", x{{'@', 1}, {'#', 2}, {'\n', 4}, {-1, 4}}},
			{"@%:$#", x{{'@', 1}, {'#', 2}, {IDENTIFIER, 4}, {'#', 5}, {'\n', 6}, {-1, 6}}},
			{"@%:@", x{{'@', 1}, {'#', 2}, {'@', 4}, {'\n', 5}, {-1, 5}}},
			{"@%:@#", x{{'@', 1}, {'#', 2}, {'@', 4}, {'#', 5}, {'\n', 6}, {-1, 6}}},
			{"@%@", x{{'@', 1}, {'%', 2}, {'@', 3}, {'\n', 4}, {-1, 4}}},
			{"@'\\''%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\0'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\01'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 7}, {'\n', 8}, {-1, 8}}},
			{"@'\\012'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 8}, {'\n', 9}, {-1, 9}}},
			{"@'\\?'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\U12345678'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 14}, {'\n', 15}, {-1, 15}}},
			{"@'\\\"'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\\\'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\a'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\b'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\f'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\n'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\r'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\t'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\u1234'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 10}, {'\n', 11}, {-1, 11}}},
			{"@'\\v'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 6}, {'\n', 7}, {-1, 7}}},
			{"@'\\x12'%", x{{'@', 1}, {CHARCONST, 2}, {'%', 8}, {'\n', 9}, {-1, 9}}},
			{"@??/#\n", x{{'@', 1}, {'\\', 2}, {'#', 5}, {'\n', 6}, {-1, 7}}},
			{"@??/#\n$", x{{'@', 1}, {'\\', 2}, {'#', 5}, {'\n', 6}, {IDENTIFIER, 7}, {'\n', 8}, {-1, 8}}},
			{"@??/#\n@", x{{'@', 1}, {'\\', 2}, {'#', 5}, {'\n', 6}, {'@', 7}, {'\n', 8}, {-1, 8}}},
			{"@??/\n", x{{'@', 1}, {'\n', 6}, {-1, 6}}},
			{"@??/\n#", x{{'@', 1}, {'#', 6}, {'\n', 7}, {-1, 7}}},
			{"@??=", x{{'@', 1}, {'#', 2}, {'\n', 5}, {-1, 5}}},
			{"@\\#\n", x{{'@', 1}, {'\\', 2}, {'#', 3}, {'\n', 4}, {-1, 5}}},
			{"@\\#\n$", x{{'@', 1}, {'\\', 2}, {'#', 3}, {'\n', 4}, {IDENTIFIER, 5}, {'\n', 6}, {-1, 6}}},
			{"@\\#\n@", x{{'@', 1}, {'\\', 2}, {'#', 3}, {'\n', 4}, {'@', 5}, {'\n', 6}, {-1, 6}}},
			{"@\\\n", x{{'@', 1}, {'\n', 4}, {-1, 4}}},
			{"@\\\n#", x{{'@', 1}, {'#', 4}, {'\n', 5}, {-1, 5}}},
			{"@\x00", x{{'@', 1}, {0, 2}, {'\n', 3}, {-1, 3}}},
			{"@\x00#", x{{'@', 1}, {0, 2}, {'#', 3}, {'\n', 4}, {-1, 4}}},
			{"L", x{{IDENTIFIER, 1}, {'\n', 2}, {-1, 2}}},
			{"L'x'", x{{LONGCHARCONST, 1}, {'\n', 5}, {-1, 5}}},
			{"L\"\"", x{{LONGSTRINGLITERAL, 1}, {'\n', 4}, {-1, 4}}},
			{"L\"\"@", x{{LONGSTRINGLITERAL, 1}, {'@', 4}, {'\n', 5}, {-1, 5}}},
			{"\"(a\\\n\\u010d\\U0000010D\\\\\\'\\\"\"", x{{STRINGLITERAL, 1}, {'\n', 29}, {-1, 29}}},
			{"\"\"", x{{STRINGLITERAL, 1}, {'\n', 3}, {-1, 3}}},
			{"\"\"@", x{{STRINGLITERAL, 1}, {'@', 3}, {'\n', 4}, {-1, 4}}},
			{"\\@\n", x{{'\\', 1}, {'@', 2}, {'\n', 3}, {-1, 4}}},
			{"\\@\n#", x{{'\\', 1}, {'@', 2}, {'\n', 3}, {'#', 4}, {'\n', 5}, {-1, 5}}},
			{"\\\n", x{{'\n', 3}, {-1, 3}}},
			{"\\\n@", x{{'@', 3}, {'\n', 4}, {-1, 4}}},
			{"\n", x{{'\n', 1}, {-1, 2}}},
			{"\r", x{{'\n', 2}, {-1, 2}}},
			{"\r@", x{{'@', 2}, {'\n', 3}, {-1, 3}}},
			{"\r@#", x{{'@', 2}, {'#', 3}, {'\n', 4}, {-1, 4}}},
			{"\x00", x{{0, 1}, {'\n', 2}, {-1, 2}}},
			{"\x00@", x{{0, 1}, {'@', 2}, {'\n', 3}, {-1, 3}}},
			{"^=", x{{XORASSIGN, 1}, {'\n', 3}, {-1, 3}}},
			{"_", x{{IDENTIFIER, 1}, {'\n', 2}, {-1, 2}}},
			{"_@", x{{IDENTIFIER, 1}, {'@', 2}, {'\n', 3}, {-1, 3}}},
			{"_Bool", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"_Complex", x{{IDENTIFIER, 1}, {'\n', 9}, {-1, 9}}},
			{"_Imaginary", x{{IDENTIFIER, 1}, {'\n', 11}, {-1, 11}}},
			{"_a", x{{IDENTIFIER, 1}, {'\n', 3}, {-1, 3}}},
			{"auto", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"a·", x{{IDENTIFIER, 1}, {'\n', 4}, {-1, 4}}},
			{"a·z", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"brea", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"breaj", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"break", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"breaks", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"case", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"char", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"const", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"continue", x{{IDENTIFIER, 1}, {'\n', 9}, {-1, 9}}},
			{"default", x{{IDENTIFIER, 1}, {'\n', 8}, {-1, 8}}},
			{"define", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"do", x{{IDENTIFIER, 1}, {'\n', 3}, {-1, 3}}},
			{"double", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"elif", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"else", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"endif", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"enum", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"error", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"extern", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"float", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"for", x{{IDENTIFIER, 1}, {'\n', 4}, {-1, 4}}},
			{"goto", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"if", x{{IDENTIFIER, 1}, {'\n', 3}, {-1, 3}}},
			{"ifdef", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"ifndef", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"include", x{{IDENTIFIER, 1}, {'\n', 8}, {-1, 8}}},
			{"inline", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"int", x{{IDENTIFIER, 1}, {'\n', 4}, {-1, 4}}},
			{"line", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"long", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"pragma", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"register", x{{IDENTIFIER, 1}, {'\n', 9}, {-1, 9}}},
			{"restrict", x{{IDENTIFIER, 1}, {'\n', 9}, {-1, 9}}},
			{"return", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"short", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"signed", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"sizeof", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"static", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"struct", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"switch", x{{IDENTIFIER, 1}, {'\n', 7}, {-1, 7}}},
			{"typedef", x{{IDENTIFIER, 1}, {'\n', 8}, {-1, 8}}},
			{"undef", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"union", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"unsigned", x{{IDENTIFIER, 1}, {'\n', 9}, {-1, 9}}},
			{"v", x{{IDENTIFIER, 1}, {'\n', 2}, {-1, 2}}},
			{"v\\", x{{IDENTIFIER, 1}, {'\\', 2}, {'\n', 3}, {-1, 3}}},
			{"v\\#\n", x{{IDENTIFIER, 1}, {'\\', 2}, {'#', 3}, {'\n', 4}, {-1, 5}}},
			{"void", x{{IDENTIFIER, 1}, {'\n', 5}, {-1, 5}}},
			{"volatile", x{{IDENTIFIER, 1}, {'\n', 9}, {-1, 9}}},
			{"vw", x{{IDENTIFIER, 1}, {'\n', 3}, {-1, 3}}},
			{"while", x{{IDENTIFIER, 1}, {'\n', 6}, {-1, 6}}},
			{"|=", x{{ORASSIGN, 1}, {'\n', 3}, {-1, 3}}},
			{"||", x{{OROR, 1}, {'\n', 3}, {-1, 3}}},
			{"·", x{{IDENTIFIER, 1}, {'\n', 3}, {-1, 3}}},
			{"·z", x{{IDENTIFIER, 1}, {'\n', 4}, {-1, 4}}},
			{`""`, x{{STRINGLITERAL, 1}, {'\n', 3}, {-1, 3}}},
		},
	)
}

func TestPPParseCorpus(t *testing.T) {
	var tsz int64
	var files, nLex int
	lst, err := os.Open(filepath.Join(testCorpusDir, testFileList))
	if err != nil {
		t.Fatal(err)
	}

	bs := bufio.NewScanner(lst)
	limit := *oMaxFiles
	m := map[string]*nodeStat{}
next:
	for bs.Scan() {
		fn := bs.Text()
		for _, v := range blacklist {
			if strings.Contains(fn, v) {
				continue next
			}
		}

		f, err := os.Open(fn)
		if err != nil {
			t.Fatal(err)
		}

		func() {
			defer func() {
				if err := f.Close(); err != nil {
					t.Fatal(err)
				}
			}()

			fi, err := f.Stat()
			if err != nil {
				t.Fatal(err)
			}

			tsz += fi.Size()
			scanner := newUtf8src(f, fileset.AddFile(fn, -1, int(fi.Size())))
			lx := newLexer(scanner, false)
			defer lx.close()

			ast := parsePreprocessingFile(lx)
			if err := compilation.Errors(true); err != nil {
				t.Fatal(err)
			}

			astSum(m, ast)
			files++
		}()

		limit--
		if limit == 0 {
			break
		}
	}
	if err := bs.Err(); err != nil {
		t.Fatal(err)
	}
	t.Logf("files: %d, bytes %v", files, tsz)
	t.Logf("nLex %d", nLex)
	s := astStats(t, m)

	// 2015-02-14 @ 4670
	// all_test.go:1111: files: 68 890, bytes 618 197 894, zip 466 069 308
	// all_test.go:1112: nLex 112 820 602
	// all_test.go:1266:   ElifGroupListOpt:       1 683 x  16 bytes =        26 928 bytes
	// all_test.go:1266:      ElifGroupList:       2 736 x  24 bytes =        65 664 bytes
	// all_test.go:1266:          ElifGroup:       2 736 x  32 bytes =        87 552 bytes
	// all_test.go:1266:       ElseGroupOpt:      24 483 x  16 bytes =       391 728 bytes
	// all_test.go:1266:  PreprocessingFile:      68 890 x   8 bytes =       551 120 bytes
	// all_test.go:1266:          ElseGroup:      24 483 x  24 bytes =       587 592 bytes
	// all_test.go:1266:  IdentifierListOpt:     112 623 x  16 bytes =     1 801 968 bytes
	// all_test.go:1266:       GroupListOpt:     141 923 x  16 bytes =     2 270 768 bytes
	// all_test.go:1266:          EndifLine:     114 804 x  24 bytes =     2 755 296 bytes
	// all_test.go:1266:          IfSection:     114 804 x  32 bytes =     3 673 728 bytes
	// all_test.go:1266:            IfGroup:     114 804 x  56 bytes =     6 429 024 bytes
	// all_test.go:1266:     IdentifierList:     188 145 x  48 bytes =     9 030 960 bytes
	// all_test.go:1266:        PPTokenList:  16 637 469 x   8 bytes =   133 099 752 bytes
	// all_test.go:1266:        ControlLine:   1 327 915 x 128 bytes =   169 973 120 bytes
	// all_test.go:1266:                int:  36 034 495 x   8 bytes =   288 275 960 bytes
	// all_test.go:1266:              Token:  23 792 621 x  16 bytes =   380 681 936 bytes
	// all_test.go:1266:          GroupList:  19 042 973 x  24 bytes =   457 031 352 bytes
	// all_test.go:1266:          GroupPart:  15 077 210 x  48 bytes =   723 706 080 bytes
	// all_test.go:1268: Sum:  2 180 440 528 bytes

	// 2015-02-24 @ 4670
	// --- PASS: TestPPParseCorpus (100.43s)
	// all_test.go:1115: files: 68 890, bytes 618 197 894
	// all_test.go:1116: nLex 112 889 492
	// all_test.go:1291:  ElifGroupListOpt:      1 683 x  16 bytes =         26 928 bytes
	// all_test.go:1291:     ElifGroupList:      2 736 x  24 bytes =         65 664 bytes
	// all_test.go:1291:         ElifGroup:      2 736 x  32 bytes =         87 552 bytes
	// all_test.go:1291:      ElseGroupOpt:     24 483 x  16 bytes =        391 728 bytes
	// all_test.go:1291: PreprocessingFile:     68 890 x   8 bytes =        551 120 bytes
	// all_test.go:1291:         ElseGroup:     24 483 x  40 bytes =        979 320 bytes
	// all_test.go:1291: IdentifierListOpt:     112 623 x  16 bytes =     1 801 968 bytes
	// all_test.go:1291:      GroupListOpt:     141 923 x  16 bytes =     2 270 768 bytes
	// all_test.go:1291:         EndifLine:     114 804 x  24 bytes =     2 755 296 bytes
	// all_test.go:1291:         IfSection:     114 804 x  32 bytes =     3 673 728 bytes
	// all_test.go:1291:           IfGroup:     114 804 x  72 bytes =     8 265 888 bytes
	// all_test.go:1291:    IdentifierList:     188 145 x  48 bytes =     9 030 960 bytes
	// all_test.go:1291:               int:   1 914 312 x   8 bytes =    15 314 496 bytes
	// all_test.go:1291:       PpTokenList:  19 293 299 x   8 bytes =   154 346 392 bytes
	// all_test.go:1291:       ControlLine:   1 327 915 x 144 bytes =   191 219 760 bytes
	// all_test.go:1291:         GroupList:  15 077 210 x  16 bytes =   241 235 360 bytes
	// all_test.go:1291:             Token:  23 931 908 x  16 bytes =   382 910 528 bytes
	// all_test.go:1291:         GroupPart:  15 077 210 x  40 bytes =   603 088 400 bytes
	// all_test.go:1293:      ast 1 618 015 856
	// all_test.go:1172: toks len   452 201 236, cap  452 984 832, wasted   783 596 ( 0.2%)
	// all_test.go:1175: dict len    51 316 180
	// all_test.go:1176:      sum 2 121 533 272

	// 2015-02-17 @ r550
	// --- PASS: TestPPParseCorpus (196.45s)
	// all_test.go:1112: files: 68 890, bytes 618 197 894
	// all_test.go:1113: nLex 112 820 602
	// all_test.go:1305:  ElifGroupListOpt:       1 683 x  16 bytes =        26 928 bytes
	// all_test.go:1305:     ElifGroupList:       2 736 x  24 bytes =        65 664 bytes
	// all_test.go:1305:         ElifGroup:       2 736 x  32 bytes =        87 552 bytes
	// all_test.go:1305:      ElseGroupOpt:      24 483 x  16 bytes =       391 728 bytes
	// all_test.go:1305: PreprocessingFile:      68 890 x   8 bytes =       551 120 bytes
	// all_test.go:1305:         ElseGroup:      24 483 x  24 bytes =       587 592 bytes
	// all_test.go:1305: IdentifierListOpt:     112 623 x  16 bytes =     1 801 968 bytes
	// all_test.go:1305:      GroupListOpt:     141 923 x  16 bytes =     2 270 768 bytes
	// all_test.go:1305:         EndifLine:     114 804 x  24 bytes =     2 755 296 bytes
	// all_test.go:1305:         IfSection:     114 804 x  32 bytes =     3 673 728 bytes
	// all_test.go:1305:           IfGroup:     114 804 x  56 bytes =     6 429 024 bytes
	// all_test.go:1305:    IdentifierList:     188 145 x  48 bytes =     9 030 960 bytes
	// all_test.go:1305:       PPTokenList:  16 637 469 x   8 bytes =   133 099 752 bytes
	// all_test.go:1305:       ControlLine:   1 327 915 x 128 bytes =   169 973 120 bytes
	// all_test.go:1305:               int:  36 034 495 x   8 bytes =   288 275 960 bytes
	// all_test.go:1305:             Token:  23 792 621 x  16 bytes =   380 681 936 bytes
	// all_test.go:1305:         GroupList:  19 042 973 x  24 bytes =   457 031 352 bytes
	// all_test.go:1305:         GroupPart:  15 077 210 x  48 bytes =   723 706 080 bytes
	// all_test.go:1307:      ast 2 180 440 528
	// all_test.go:1168: toks len   466 069 308, cap  466 616 320, wasted   547 012 ( 0.1%)
	// all_test.go:1171: dict len    57 115 533
	// all_test.go:1172:      sum 2 703 625 369

	// 2015-03-02 @ r550
	// === RUN TestPPParseCorpus
	// --- PASS: TestPPParseCorpus (242.06s)
	// all_test.go:1126: files: 68 890, bytes 618 197 894
	// all_test.go:1127: nLex 112 889 492
	// all_test.go:1336:  ElifGroupListOpt:       1 683 x  16 bytes =         26 928 bytes
	// all_test.go:1336:     ElifGroupList:       2 736 x  24 bytes =         65 664 bytes
	// all_test.go:1336:         ElifGroup:       2 736 x  32 bytes =         87 552 bytes
	// all_test.go:1336:      ElseGroupOpt:      24 483 x  16 bytes =        391 728 bytes
	// all_test.go:1336: PreprocessingFile:      68 890 x   8 bytes =        551 120 bytes
	// all_test.go:1336:         ElseGroup:      24 483 x  40 bytes =        979 320 bytes
	// all_test.go:1336: IdentifierListOpt:     112 623 x  16 bytes =      1 801 968 bytes
	// all_test.go:1336:      GroupListOpt:     141 923 x  16 bytes =      2 270 768 bytes
	// all_test.go:1336:         EndifLine:     114 804 x  24 bytes =      2 755 296 bytes
	// all_test.go:1336:         IfSection:     114 804 x  32 bytes =      3 673 728 bytes
	// all_test.go:1336:           IfGroup:     114 804 x  72 bytes =      8 265 888 bytes
	// all_test.go:1336:    IdentifierList:     188 145 x  48 bytes =      9 030 960 bytes
	// all_test.go:1336:               int:   1 914 312 x   8 bytes =     15 314 496 bytes
	// all_test.go:1336:       PpTokenList:  19 293 299 x   8 bytes =    154 346 392 bytes
	// all_test.go:1336:       ControlLine:   1 327 915 x 144 bytes =    191 219 760 bytes
	// all_test.go:1336:         GroupList:  15 077 210 x  16 bytes =    241 235 360 bytes
	// all_test.go:1336:             Token:  23 931 908 x  16 bytes =    382 910 528 bytes
	// all_test.go:1336:         GroupPart:  15 077 210 x  40 bytes =    603 088 400 bytes
	// all_test.go:1338:      ast 1 618 015 856
	// all_test.go:1210: toks len   465 910 598, cap  466 616 320, wasted   705 722 ( 0.2%)
	// all_test.go:1213: dict len    56 073 034
	// all_test.go:1214:      sum 2 139 999 488

	// 2015-07-12 @ 4670
	// === RUN TestPPParseCorpus
	// --- PASS: TestPPParseCorpus (119.86)
	// all_test.go:929: files: 68 889, bytes 618 308 084
	// all_test.go:930: nLex 0
	// all_test.go:1164:  ElifGroupListOpt:       1 688 x   8 bytes =        13 504 bytes
	// all_test.go:1164:     ElifGroupList:       2 741 x  24 bytes =        65 784 bytes
	// all_test.go:1164:         ElifGroup:       2 741 x  32 bytes =        87 712 bytes
	// all_test.go:1164:      ElseGroupOpt:      24 496 x   8 bytes =       195 968 bytes
	// all_test.go:1164: PreprocessingFile:      68 889 x   8 bytes =       551 112 bytes
	// all_test.go:1164: IdentifierListOpt:     112 635 x   8 bytes =       901 080 bytes
	// all_test.go:1164:         ElseGroup:      24 496 x  40 bytes =       979 840 bytes
	// all_test.go:1164:      GroupListOpt:     141 975 x   8 bytes =     1 135 800 bytes
	// all_test.go:1164:         EndifLine:     114 838 x  24 bytes =     2 756 112 bytes
	// all_test.go:1164:         IfSection:     114 838 x  32 bytes =     3 674 816 bytes
	// all_test.go:1164:           IfGroup:     114 838 x  72 bytes =     8 268 336 bytes
	// all_test.go:1164:    IdentifierList:     188 162 x  48 bytes =     9 031 776 bytes
	// all_test.go:1164:               int:   1 633 711 x   8 bytes =    13 069 688 bytes
	// all_test.go:1164:       PpTokenList:  19 295 257 x   8 bytes =   154 362 056 bytes
	// all_test.go:1164:       ControlLine:   1 327 970 x 144 bytes =   191 227 680 bytes
	// all_test.go:1164:         GroupList:  15 078 930 x  16 bytes =   241 262 880 bytes
	// all_test.go:1164:             Token:  23 934 159 x  16 bytes =   382 946 544 bytes
	// all_test.go:1164:         GroupPart:  15 078 930 x  40 bytes =   603 157 200 bytes
	// all_test.go:1166:      ast 1 613 687 888
	// all_test.go:1041: toks len   469 974 673, cap  470 810 624, wasted   835 951 ( 0.2%)
	// all_test.go:1042:      sum 2 083 662 561

	l, c := db.len(), db.cap()
	s += l
	w := c - l
	t.Logf("toks len %10v, cap %10v, wasted %8v (%4.1f%%)", l, c, w, 100*float64(w)/float64(c))
	t.Logf("     sum %10v", s)
}

/*TODO Add test(s):

- Neither `#error' nor `#warning' macro-expands its argument. Internal
whitespace sequences are each replaced with a single space. The line must
consist of complete tokens. It is wisest to make the argument of these
directives be a single string constant; this avoids problems with apostrophes
and the like.

  https://gcc.gnu.org/onlinedocs/gcc-4.5.0/cpp/Diagnostics.html

- No macro expansion occurs on any ‘#pragma’ directive line, so the question
does not arise.

	https://gcc.gnu.org/onlinedocs/cpp/Implementation-defined-behavior.html#Implementation-defined-behavior

- The ‘#’ which begins a directive cannot come from a macro expansion. Also,
the directive name is not macro expanded. Thus, if foo is defined as a macro
expanding to define, that does not make ‘#foo’ a valid preprocessing directive.

  https://gcc.gnu.org/onlinedocs/cpp/The-preprocessing-language.html#The-preprocessing-language

- The null directive consists of a ‘#’ followed by a newline, with only
whitespace (including comments) in between. A null directive is understood as a
preprocessing directive but has no effect on the preprocessor output. The
primary significance of the existence of the null directive is that an input
line consisting of just a ‘#’ will produce no output, rather than a line of
output containing just a ‘#’. Supposedly some old C programs contain such
lines.

	https://gcc.gnu.org/onlinedocs/cpp/Other-Directives.html

*/

var onceBenchmarkPPParseCorpus sync.Once

func BenchmarkPPParseCorpus(b *testing.B) {
	var a []*PreprocessingFile
	var tsz int64
	var nLex int

	for i := 0; i < b.N; i++ {
		b.StopTimer()
		lst, err := os.Open(filepath.Join(testCorpusDir, testFileList))
		if err != nil {
			b.Fatal(err)
		}

		bs := bufio.NewScanner(lst)
		limit := *oMaxBenchFiles
		a = a[:0]
		runtime.GC()
		b.StartTimer()
	next:
		for bs.Scan() {
			fn := bs.Text()
			for _, v := range blacklist {
				if strings.Contains(fn, v) {
					continue next
				}
			}

			f, err := os.Open(fn)
			if err != nil {
				b.Fatal(err)
			}

			func() {
				defer func() {
					if err := f.Close(); err != nil {
						b.Fatal(err)
					}
				}()

				fi, err := f.Stat()
				if err != nil {
					b.Fatal(err)
				}

				tsz += fi.Size()
				scanner := newUtf8src(f, fileset.AddFile(fn, -1, int(fi.Size())))
				lx := newLexer(scanner, false)
				defer lx.close()

				ast := parsePreprocessingFile(lx)
				a = append(a, ast)
			}()

			limit--
			if limit == 0 {
				break
			}
		}
		if err := bs.Err(); err != nil {
			b.Fatal(err)
		}
	}
	b.StopTimer()
	b.SetBytes(tsz)
	onceBenchmarkPPParseCorpus.Do(func() {
		b.Logf("files: %d, bytes %v", len(a), tsz)
		b.Logf("nLex %d", nLex)
	})
}

func astStats(t testing.TB, m map[string]*nodeStat) int {
	var w int
	for k := range m {
		w = mathutil.Max(w, len(k))
	}
	var a []string
	var sum int
	for k, v := range m {
		mem := v.instances * v.sizeof
		sum += mem
		a = append(a, fmt.Sprintf("%11d%*s: %9d x %3d bytes = %11d bytes", mem, w, k, v.instances, v.sizeof, mem))
	}
	sort.Strings(a)
	for _, v := range a {
		v = v[11:]
		t.Log(v)
	}
	t.Logf("     ast %10v", sum)
	return sum
}

func TestDBInt(t *testing.T) {
	const n = 18e5
	rng := newRng()
	db := newTokDB()
	exp := map[int]int{}
	for i := 0; i < n; i++ {
		x := rng.Next()
		id := db.putInt(x)
		if _, ok := exp[id]; ok {
			t.Fatal(i, id)
		}

		exp[id] = x
	}
	for id, e := range exp {
		if g := db.int(id); g != e {
			t.Fatal(id, g, e)
		}
	}
	l, c := db.len(), db.cap()
	w := c - l
	t.Logf("len %v, cap %v, wasted %v (%.1f%%)", l, c, w, 100*float64(w)/float64(c))
}

func testDBIntpUnlocked(t *testing.T, n int) {
	const lim = dbPageSize + maxUvarint
	db := newTokDB()
	var ids []int
	for id := 0; id < lim; {
		id = db.putIntUnlocked(n)
		ids = append(ids, id)
	}
	for i := 0; i < len(ids)-1; i++ {
		id := PpTokenList(ids[i])
		id0 := id
		gn := db.intpUnlocked(&id)
		if g, e := gn, n; g != e {
			t.Fatal(int(id0), int(id), g, e)
		}

		if g, e := int(id), ids[i+1]; g != e {
			t.Fatal(g, e)
		}
	}
}

func TestDBIntpUnlocked3(t *testing.T) {
	n := 0x12345 // 3 byte uvarint
	testDBIntpUnlocked(t, n)
}

func TestDBIntpUnlocked5(t *testing.T) {
	n := 0x123456789 // 5 byte uvarint
	testDBIntpUnlocked(t, n)
}

func TestDBIntpUnlocked7(t *testing.T) {
	n := 0x123456789ab // 7 byte uvarint
	testDBIntpUnlocked(t, n)
}

func testPreprocOne(t *testing.T, fn string, undef, stats bool) {
	if undef {
		Macros = map[int]*macro{}
	}
	fi, err := os.Stat(fn)
	if err != nil {
		t.Fatal(err)
	}

	f := ppFile(xc.Token{}, fn)
	if f == nil {
		t.Fatal(compilation.Errors(true))
	}

	if stats {
		t.Logf("files: %d, bytes %v", 1, fi.Size())
	}
	m := map[string]*nodeStat{}
	astSum(m, f)
	var s int
	if stats {
		s = astStats(t, m)
	}
	ch := make(chan []xc.Token, 1000)
	var plines, ptoks int
	wait := make(chan int, 1)
	go func() {
		for line := range ch {
			plines++
			ptoks += len(line)
		}
		wait <- 1
	}()

	func() {
		defer close(ch)

		f.preprocess(newEvalCtx(newLexer(nil, false), ch))
	}()

	if err := compilation.Errors(true); err != nil {
		t.Fatal(errString(err))
	}

	if !stats {
		return
	}
	l, c := db.len(), db.cap()
	s += l
	w := c - l
	t.Logf("toks len %10v, cap %10v, wasted %8v (%4.1f%%)", l, c, w, 100*float64(w)/float64(c))
	t.Logf("     sum %10v", s)
	<-wait
	t.Logf("preprocessor emited %v lines, %v tokens", plines, ptoks)
}

func TestPreprocSQLiteC(t *testing.T) {
	testPreprocOne(t, "testdata/sqlite-amalgamation-3081002/sqlite3.c", true, true)
}

func TestPreprocSQLiteH(t *testing.T) {
	testPreprocOne(t, "testdata/sqlite-amalgamation-3081002/sqlite3.h", true, true)
}

func TestPreprocArith(t *testing.T) {
	testPreprocOne(t, "testdata/gcc-4.9.1/gcc/testsuite/gcc.dg/cpp/arith-1.c", true, false)
}
